+++
date = 2025-07-08T14:34:43+03:00
title = "Простые DSL, которые работают"
taxonomies.tags = ["ai-translation"]
+++

Год назад я выпустил [auto-typing-final](https://github.com/community-of-python/auto-typing-final) — исправитель и линтер, реализующий правило из [руководства по стилю](https://github.com/community-of-python/pylines/blob/6a9fa5d46c46fecce66749760ad745d64e1c2c14/code-style.md) сообщества Python Raiffeisenbank России: «используйте `typing.Final` для констант». Сейчас он интегрирован во всей нашей кодовой базе (даже есть расширение для VS Code).

Вдохновлённый работой над Ty в [Ruff](https://github.com/charliermarsh/ruff) и PR Карла Мейера с фреймворком тестирования на основе Markdown [в Ruff](https://github.com/astral-sh/ruff/pull/13636), где показано, как встроенные примеры тестов в Markdown могут упростить и тестирование, и документацию.

Чтобы упростить и тесты, и документацию, я [реализовал](https://github.com/community-of-python/auto-typing-final/pull/125) простой внутренний DSL на основе Markdown для определения сценариев преобразований прямо в тексте:

```md
### Множественные присваивания с `Final`

```python
a: Final = 1  # удалить («удалить» означает, что нужно убрать «Final». Есть ещё «вставить» — обратное действие)
a = 2
```

Такие примеры заменили сложную параметризацию с многострочными строками.

**Почему этот внутренний DSL работает:**

- Повышает ясность. Заголовки описывают каждый тестовый случай, а блоки кода с разделителями отделяют входные данные, ожидаемые изменения и аннотации.

- Единый источник истины. Один и тот же фрагмент Markdown одновременно управляет параметризацией pytest и служит пользовательской документацией.

## Вывод
Небольшие DSL, подобные этому, работают эффективно: их легко парсить, читать и писать.
Этот пример доказывает, что порой самые простые инструменты оказывают наибольшее влияние.
